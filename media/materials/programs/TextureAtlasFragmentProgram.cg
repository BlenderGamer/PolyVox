struct v2f
{
    float4 Position : POSITION; //in projection space
    float4 Color : COLOR;
    float4 TexCoords : TEXCOORD0;
    float4 Normal : TEXCOORD1;
    float2 Alpha : TEXCOORD2;
};

float4 main(v2f IN, uniform sampler2D colourMap : TEXUNIT0) : COLOR
{
	//return float4(IN.Alpha.y, 1.0f-IN.Alpha.y, 0.0f,1.0f);
	
	float textureScalingFactor = 20.0f;
	float textureSize = 512.0f;
	float noOfTexturesPerDimension = 4.0;
	
	//Scale the texture.
	IN.TexCoords /= textureScalingFactor;
	
	//Make sure texture coordinates are in the range 0.0 - 1.0 (or 0.9999? Is this necessary?)
	IN.TexCoords.x = frac(IN.TexCoords.x);
	IN.TexCoords.y = frac(IN.TexCoords.y);
	IN.TexCoords.z = frac(IN.TexCoords.z);
	
	//Now scale the texture coordinates to the right range for the texture atlas.
	IN.TexCoords /= noOfTexturesPerDimension;	
	
	//Next we compute the offset of the texture in the texture atlas
	float material = floor(IN.Alpha.x);
	float y = floor(material / noOfTexturesPerDimension);
	float x = fmod(material,noOfTexturesPerDimension);
	float2 offset = float2(x,y);
	offset /= noOfTexturesPerDimension;	
	
	//Retrieve the 3 samples
	float3 colourMapValueXY = tex2D(colourMap, IN.TexCoords.xy + offset).rgb * abs(IN.Normal.z);
	float3 colourMapValueYZ = tex2D(colourMap, IN.TexCoords.yz + offset).rgb * abs(IN.Normal.x);
	float3 colourMapValueXZ = tex2D(colourMap, IN.TexCoords.xz + offset).rgb * abs(IN.Normal.y);

	//Blend according to triplanar texturing
	float3 colourMapValue = colourMapValueXY + colourMapValueYZ + colourMapValueXZ;

	//Return the result
	return float4(colourMapValue*IN.Color.rgb*IN.Alpha.y,IN.Alpha.y);
}